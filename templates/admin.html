<!doctype html>
<meta charset="utf-8"/>
<title>DMX Admin</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root { color-scheme: light; }
  body { font-family: system-ui, sans-serif; margin: 0; padding: 20px; background:#fff; color:#222; }
  .header-bar { display:flex; justify-content:space-between; align-items:center; margin-bottom:24px; padding-bottom:16px; border-bottom:2px solid #a53792; }
  .header-bar h1 { margin:0; color:#a53792; }
  .logo { height:64px; width:auto; object-fit:contain; display:block; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
  .card { border:1px solid #ddd; border-radius:12px; padding:16px; background:#f5f5f5; margin-bottom:16px; }
  .scene-card { border-left: 4px solid #a53792; }
  input, select, button { background:#fff; color:#222; border:1px solid #ccc; border-radius:8px; padding:8px 10px; }
  button { cursor:pointer; transition: all 0.2s; }
  .btn { padding:8px 12px; border-radius:10px; border:1px solid #ccc; background:#fff;}
  .btn:hover { background:#f0f0f0; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
  .btn-primary { background:#a53792; color:#fff; border-color:#a53792; }
  .btn-primary:hover { background:#8e2d7d; }
  .btn-success { background:#a6ce39; color:#fff; border-color:#a6ce39; }
  .btn-success:hover { background:#8fb52e; }
  .btn-info { background:#00aeef; color:#fff; border-color:#00aeef; }
  .btn-info:hover { background:#0092cc; }
  .btn-warning { background:#ffc000; color:#222; border-color:#ffc000; }
  .btn-warning:hover { background:#e6ad00; }
  .scenes-list { display:flex; flex-direction:column; gap:16px; }
  .tiny { font-size:.9em; opacity:.7; }
  .pill { padding:4px 12px; border:1px solid #a53792; border-radius:999px; background:#fff; color:#a53792; font-weight:500; }
  .section-title { font-weight:700; font-size:1.3rem; margin:24px 0 16px 0; color:#a53792; }
  .danger { background:#dc3545; color:#fff; border-color:#dc3545; }
  .danger:hover { background:#c82333; }

  .companion-uri { background:#f8f9fa; padding:8px 12px; border:1px solid #ccc; border-radius:6px; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:0.9em; display:inline-flex; align-items:center; gap:8px; margin-top:8px; }
  .copy-btn { padding:4px 10px; font-size:0.85em; }
  .fixture-grid { display:grid; grid-template-columns: repeat(auto-fill,minmax(350px,1fr)); gap:12px; }

  /* FIX: Sequence-Step Hintergrund hell */
  .step-card{ background:#fff !important; border:1px solid #ddd; }

  .index-pill{
    display:inline-flex; align-items:center; gap:6px;
    padding:6px 10px; border:1px solid #ccc; border-radius:10px; background:#fff; font-weight:700;
  }
</style>

<div class="header-bar">
  <h1>DMX Controller Admin</h1>
  <img src="{{logo_url}}" class="logo" alt="Logo">
</div>

<div class="card">
  <div class="row">
    <span class="pill">Global Dimmer: <b id="dim-val">100%</b></span>
    <button class="btn btn-warning" onclick="dimStep(-10)">âˆ’10%</button>
    <button class="btn btn-warning" onclick="dimStep(10)">+10%</button>
    <input id="dim-set" type="number" style="width:90px" min="0" max="100" value="100">
    <button class="btn btn-primary" onclick="dimSet()">Set Dimmer</button>
  </div>
</div>

<div class="card">
  <div class="row">
    <label>Universe <input id="universe" type="number" min="1" value="1" style="width:100px"></label>
    <label>Default Dimmer <input id="def-dimmer" type="number" min="0" max="255" value="255" style="width:120px"></label>
    <label>Default Strobe <input id="def-strobe" type="number" min="0" max="255" value="0" style="width:120px"></label>
    <button class="btn btn-success" onclick="saveState()">ðŸ’¾ Save Settings</button>
    <button class="btn btn-info" onclick="reloadState()">â¤³ Reload</button>
    <span class="tiny" id="status"></span>
  </div>
</div>

<div class="section-title">Fixtures</div>
<div id="fixtures" class="fixture-grid"></div>
<button class="btn btn-primary" onclick="addFixture()">+ Add Fixture</button>

<div class="section-title">Scenes</div>
<div id="buttons" class="scenes-list"></div>
<button class="btn btn-primary" onclick="addButton()">+ Add Scene</button>

<template id="tpl-fixture">
  <div class="card">
    <div class="row">
      <label>Name <input class="fx-name" style="width:160px"></label>
      <label>Start Ch <input class="fx-start" type="number" min="1" style="width:90px"></label>
      <label>Mode
        <select class="fx-mode">
          <option>RGB</option><option selected>RGBW</option>
        </select>
      </label>
      <label>Map (opt) <input class="fx-map" placeholder="z.B. DIM,R,G,B,W" style="width:220px"></label>
      <button class="btn danger" onclick="delFixture(this)">Delete</button>
    </div>
  </div>
</template>

<template id="tpl-button">
  <div class="card scene-card">
    <div class="row" style="justify-content:space-between; margin-bottom:12px;">
      <div class="row">
        <span class="index-pill">Index: <span class="bt-index-text">0</span></span>
        <label>Label <input class="bt-label" style="width:220px"></label>
        <label>Type
          <select class="bt-type">
            <option>static</option>
            <option>per-fixture</option>
            <option>sequence</option>
            <option>blackout</option>
          </select>
        </label>
      </div>
      <div class="row">
        <button class="btn btn-info" onclick="triggerScene(this)">â–¶ Test Scene</button>
        <button class="btn btn-success" onclick="downloadStreamDeckImage(this)">â¬‡ Download PNG</button>
        <button class="btn danger" onclick="delButton(this)">Delete</button>
      </div>
    </div>

    <div class="companion-uri">
      <strong>Companion URI:</strong>
      <code class="uri-text">/trigger/0?fade_ms=2000</code>
      <button class="btn copy-btn" onclick="copyURI(this)">ðŸ“‹ Copy</button>
    </div>

    <div class="bt-body"></div>
  </div>
</template>

<script>
let STATE = { universe:1, fixtures:[], defaults:{dimmer:255,strobe:0}, buttons:[] };

function el(id){ return document.getElementById(id); }
function status(msg){ el('status').textContent = msg; setTimeout(()=>el('status').textContent="", 2500); }

function hexToRgb(hex){ const v=hex.replace('#',''); const n=parseInt(v,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
function rgbToHex(r,g,b){ return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }

function colorRow(title, obj, onChange){
  const r=obj.r|0, g=obj.g|0, b=obj.b|0, w=obj.w|0;
  const wrap=document.createElement('div'); wrap.className='row'; wrap.style.marginTop='8px';
  const hex=rgbToHex(r,g,b);

  wrap.innerHTML=`
    <span style="width:120px">${title}</span>
    <input type="color" value="${hex}" class="pick">
    <span class="tiny">R:${r} G:${g} B:${b}</span>
    <span style="margin-left:15px">WeiÃŸ:</span>
    <input type="range" min="0" max="255" value="${w}" class="wslider" style="width:120px">
    <span class="tiny">${w}</span>`;

  wrap.querySelector('.pick').addEventListener('input',(e)=>{
    const {r,g,b}=hexToRgb(e.target.value);
    const newW = parseInt(wrap.querySelector('.wslider').value);
    onChange({r,g,b,w:newW});
    wrap.querySelector('.tiny:last-child').textContent = newW;
  });
  wrap.querySelector('.wslider').addEventListener('input',(e)=>{
    const newW=parseInt(e.target.value);
    const {r,g,b}=hexToRgb(wrap.querySelector('.pick').value);
    onChange({r,g,b,w:newW});
    wrap.querySelector('.tiny:last-child').textContent = newW;
  });
  return wrap;
}

// StreamDeck Image Generator (72x72 px)
function generateStreamDeckImage(button){
  const canvas = document.createElement('canvas');
  canvas.width = 72;
  canvas.height = 72;
  const ctx = canvas.getContext('2d');

  const scene = button.scene || {type:'blackout'};
  const colors = [];

  const t = (scene.type || 'blackout').toLowerCase();
  if (t === 'blackout'){
    colors.push({r:0,g:0,b:0});
  } else if (t === 'static'){
    const c = scene.all || {r:0,g:0,b:0};
    colors.push({r:c.r||0, g:c.g||0, b:c.b||0});
  } else if (t === 'per-fixture'){
    const vals = scene.values || {};
    Object.values(vals).forEach(c => colors.push({r:c.r||0, g:c.g||0, b:c.b||0}));
  } else if (t === 'sequence'){
    const steps = scene.steps || [];
    steps.forEach(st => {
      if (st.all){
        colors.push({r:st.all.r||0, g:st.all.g||0, b:st.all.b||0});
      } else if (st.values){
        Object.values(st.values).forEach(c => colors.push({r:c.r||0, g:c.g||0, b:c.b||0}));
      }
    });
  }

  if (colors.length === 0) colors.push({r:0,g:0,b:0});

  if (colors.length === 1){
    ctx.fillStyle = `rgb(${colors[0].r},${colors[0].g},${colors[0].b})`;
    ctx.fillRect(0, 0, 72, 72);
  } else if (colors.length === 2){
    ctx.fillStyle = `rgb(${colors[0].r},${colors[0].g},${colors[0].b})`;
    ctx.fillRect(0, 0, 36, 72);
    ctx.fillStyle = `rgb(${colors[1].r},${colors[1].g},${colors[1].b})`;
    ctx.fillRect(36, 0, 36, 72);
  } else if (colors.length <= 4){
    const gridSize = Math.ceil(Math.sqrt(colors.length));
    const cellW = 72 / gridSize;
    const cellH = 72 / gridSize;
    colors.forEach((c, i) => {
      const x = (i % gridSize) * cellW;
      const y = Math.floor(i / gridSize) * cellH;
      ctx.fillStyle = `rgb(${c.r},${c.g},${c.b})`;
      ctx.fillRect(x, y, cellW, cellH);
    });
  } else {
    const grad = ctx.createLinearGradient(0, 0, 0, 72);
    colors.forEach((c, i) => grad.addColorStop(i / (colors.length - 1), `rgb(${c.r},${c.g},${c.b})`));
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 72, 72);
  }

  ctx.fillStyle = '#fff';
  ctx.font = 'bold 10px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = 'rgba(0,0,0,0.8)';
  ctx.shadowBlur = 3;
  ctx.fillText(button.label || 'Scene', 36, 36);

  return canvas;
}

function downloadStreamDeckImage(btnEl){
  const idx = parseInt(btnEl.closest('.card').dataset.idx);
  const button = STATE.buttons[idx];
  const canvas = generateStreamDeckImage(button);

  canvas.toBlob(blob => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `streamdeck_${button.index}_${(button.label||'scene').replace(/\\s+/g,'_')}.png`;
    a.click();
    URL.revokeObjectURL(url);
    status('StreamDeck Bild heruntergeladen');
  });
}

// Companion URI (kopiert voller Link inkl Token)
function buildCompanionUrl(path){
  const u = new URL(path, window.location.origin);
  const token = new URLSearchParams(window.location.search).get('token');
  if (token) u.searchParams.set('token', token);
  return u.toString();
}

function copyURI(btnEl){
  const codeEl = btnEl.parentElement.querySelector('.uri-text');
  const relative = codeEl.textContent.trim();
  const full = buildCompanionUrl(relative);

  const setCopied = () => {
    const orig = btnEl.textContent;
    btnEl.textContent = 'âœ“ Copied!';
    setTimeout(()=>btnEl.textContent = orig, 1500);
  };

  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(full).then(setCopied).catch(() => copyToClipboardFallback(full, btnEl));
  } else {
    copyToClipboardFallback(full, btnEl);
  }
}

function copyToClipboardFallback(text, btnEl){
  const textarea = document.createElement('textarea');
  textarea.value = text;
  textarea.style.position = 'fixed';
  textarea.style.opacity = '0';
  document.body.appendChild(textarea);
  textarea.select();
  try {
    document.execCommand('copy');
    if (btnEl) {
      const orig = btnEl.textContent;
      btnEl.textContent = 'âœ“ Copied!';
      setTimeout(()=>btnEl.textContent = orig, 1500);
    }
  } catch (err) {
    alert('Kopieren fehlgeschlagen. URI: ' + text);
  }
  document.body.removeChild(textarea);
}

// ===== Fixtures =====
function renderFixtures(){
  const host=el('fixtures'); host.innerHTML='';
  const tpl=el('tpl-fixture');
  STATE.fixtures.forEach((f,idx)=>{
    const node=tpl.content.firstElementChild.cloneNode(true);
    node.dataset.idx=idx;
    node.querySelector('.fx-name').value=f.name||'';
    node.querySelector('.fx-start').value=f.start_channel||1;
    node.querySelector('.fx-mode').value=f.mode||'RGBW';
    node.querySelector('.fx-map').value=(f.map||[]).join(',');
    node.querySelector('.fx-name').oninput = e=>f.name=e.target.value;
    node.querySelector('.fx-start').oninput= e=>f.start_channel=parseInt(e.target.value||'1');
    node.querySelector('.fx-mode').onchange= e=>f.mode=e.target.value;
    node.querySelector('.fx-map').oninput  = e=>f.map=e.target.value.split(',').map(s=>s.trim()).filter(Boolean);
    host.appendChild(node);
  });
}
function addFixture(){ STATE.fixtures.push({name:'New', start_channel:1, mode:'RGBW', map:[]}); renderFixtures(); }
function delFixture(btn){
  const idx=parseInt(btn.closest('.card').dataset.idx);
  STATE.fixtures.splice(idx,1); renderFixtures();
}

// ===== Scenes / Buttons =====
function nextFreeIndex(){
  const used = new Set((STATE.buttons||[]).map(b => parseInt(b.index)));
  let i = 0;
  while (used.has(i)) i++;
  return i;
}

function renderButtons(){
  const host=el('buttons'); host.innerHTML='';
  const tpl=el('tpl-button');

  STATE.buttons.sort((a,b)=>a.index-b.index).forEach((b,idx)=>{
    const node=tpl.content.firstElementChild.cloneNode(true);
    node.dataset.idx=idx;

    node.querySelector('.bt-index-text').textContent = String(b.index);
    node.querySelector('.bt-label').value=b.label||'';
    node.querySelector('.uri-text').textContent = `/trigger/${b.index}?fade_ms=2000`;

    const typeSel=node.querySelector('.bt-type');
    typeSel.value=b.scene?.type||'static';

    node.querySelector('.bt-label').oninput=e=>b.label=e.target.value;

    typeSel.onchange=e=>{
      const t=e.target.value;
      if (t==='blackout'){ b.scene={type:'blackout'}; }
      else if (t==='static'){ b.scene={type:'static', all:{r:255,g:190,b:120,w:0}}; }
      else if (t==='per-fixture'){ b.scene={type:'per-fixture', values:{}}; }
      else if (t==='sequence'){
        b.scene={ type:'sequence', hold_ms:200, crossfade_ms:400,
          steps:[ {all:{r:255,g:0,b:0,w:0}}, {all:{r:0,g:0,b:255,w:0}} ] };
      }
      renderButtons();
    };

    const body=node.querySelector('.bt-body');
    const s=b.scene||{type:'static'};

    if (s.type==='static'){
      s.all = s.all || {r:255,g:190,b:120,w:0};
      body.appendChild(colorRow('All', s.all, (c)=>{ s.all=c; }));
    }
    else if (s.type==='per-fixture'){
      s.values = s.values || {};
      STATE.fixtures.forEach(f=>{
        s.values[f.name]=s.values[f.name]||{r:0,g:0,b:0,w:0};
        body.appendChild(colorRow(f.name, s.values[f.name], (c)=>{ s.values[f.name]=c; }));
      });
    }
    else if (s.type==='sequence'){
      const ctrl=document.createElement('div'); ctrl.className='row';
      ctrl.innerHTML=`<label>hold_ms <input class="hold" type="number" value="${s.hold_ms??0}" style="width:100px"></label>
                      <label>crossfade_ms <input class="xf" type="number" value="${s.crossfade_ms??0}" style="width:120px"></label>
                      <button class="btn btn-primary" onclick="addSeqStep(${idx})">+ Add Step</button>`;
      body.appendChild(ctrl);
      ctrl.querySelector('.hold').oninput=e=>s.hold_ms=parseInt(e.target.value||'0');
      ctrl.querySelector('.xf').oninput  =e=>s.crossfade_ms=parseInt(e.target.value||'0');

      (s.steps||[]).forEach((st, si)=>{
        body.appendChild(renderSeqStep(b, s, st, si));
      });
    }

    host.appendChild(node);
  });
}

function renderSeqStep(button, scene, step, si){
  const box=document.createElement('div');
  box.className='card step-card';

  const head=document.createElement('div'); head.className='row';

  const typ = step.values ? 'per-fixture' : 'all';
  const holdVal = step.hold_ms ?? '';
  const xfVal   = step.crossfade_ms ?? '';

  head.innerHTML = `
    <b>Step ${si+1}</b>
    <span class="tiny">Typ</span>
    <select class="s-type" style="width:220px">
      <option value="all"${typ==='all'?' selected':''}>all (fÃ¼r alle gleich)</option>
      <option value="per-fixture"${typ==='per-fixture'?' selected':''}>per-fixture (pro Leuchte)</option>
    </select>
    <span class="tiny">hold_ms</span><input class="s-hold" type="number" value="${holdVal}" style="width:90px" placeholder="global">
    <span class="tiny">crossfade_ms</span><input class="s-xf" type="number" value="${xfVal}" style="width:110px" placeholder="global">
    <button class="btn danger" onclick="delStep(${STATE.buttons.indexOf(button)},${si})">Delete</button>
  `;
  box.appendChild(head);

  const body=document.createElement('div'); body.className='row'; body.style.display='block';
  box.appendChild(body);

  function renderBody(){
    body.innerHTML='';
    if (step.values){
      step.values = step.values || {};
      STATE.fixtures.forEach(f=>{
        step.values[f.name] = step.values[f.name] || {r:0,g:0,b:0,w:0};
        body.appendChild(colorRow(f.name, step.values[f.name], (c)=>{ step.values[f.name]=c; }));
      });
    } else {
      step.all = step.all || {r:0,g:0,b:0,w:0};
      body.appendChild(colorRow('All', step.all, (c)=>{ step.all=c; }));
    }
  }
  renderBody();

  head.querySelector('.s-type').onchange = (e)=>{
    const t=e.target.value;
    if (t==='all'){
      const first = (step.values && Object.values(step.values)[0]) || {r:0,g:0,b:0,w:0};
      step.all = step.all || {...first};
      delete step.values;
    }else{
      step.values = step.values || {};
      if (step.all){
        STATE.fixtures.forEach(f=>{
          step.values[f.name] = step.values[f.name] || {...step.all};
        });
      }else{
        STATE.fixtures.forEach(f=>{
          step.values[f.name] = step.values[f.name] || {r:0,g:0,b:0,w:0};
        });
      }
      delete step.all;
    }
    renderBody();
  };

  head.querySelector('.s-hold').oninput = e=>{
    const v=e.target.value;
    step.hold_ms = (v===''? null : parseInt(v));
  };
  head.querySelector('.s-xf').oninput = e=>{
    const v=e.target.value;
    step.crossfade_ms = (v===''? null : parseInt(v));
  };

  return box;
}

function addSeqStep(buttonIdx){
  const b=STATE.buttons[buttonIdx];
  b.scene.steps=b.scene.steps||[];
  b.scene.steps.push({ all:{r:0,g:0,b:0,w:0} });
  renderButtons();
}

function delStep(buttonIdx, stepIdx){
  const b=STATE.buttons[buttonIdx];
  b.scene.steps.splice(stepIdx,1);
  renderButtons();
}

// ===== State I/O =====
async function reloadState(){
  const r=await fetch('/api/state'); const j=await r.json();
  STATE=j;
  el('universe').value=STATE.universe??1;
  el('def-dimmer').value=STATE.defaults?.dimmer ?? 255;
  el('def-strobe').value=STATE.defaults?.strobe ?? 0;
  renderFixtures(); renderButtons();
  const d=await (await fetch('/api/dim')).json();
  el('dim-val').textContent=(d.level ?? 100)+'%';
  el('dim-set').value=d.level ?? 100;
}
async function saveState(){
  STATE.universe=parseInt(el('universe').value||'1');
  STATE.defaults={dimmer:parseInt(el('def-dimmer').value||'255'), strobe:parseInt(el('def-strobe').value||'0')};
  const resp=await fetch('/api/state',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(STATE)});
  status(resp.ok?'Gespeichert':'Fehler beim Speichern');
}

// ===== Dimmer UI =====
async function dimStep(delta){
  const r=await fetch('/api/dim/step?delta='+delta,{method:'POST'}); const text=await r.text();
  const lvl = parseInt(text);
  el('dim-val').textContent=lvl+'%'; el('dim-set').value=lvl;
}
async function dimSet(){
  const pct=parseInt(el('dim-set').value||'100');
  const r=await fetch('/api/dim/set?percent='+pct,{method:'POST'}); const j=await r.json();
  el('dim-val').textContent=j.level+'%';
}

async function triggerScene(btnEl){
  const idx=parseInt(btnEl.closest('.card').dataset.idx);
  const scene=STATE.buttons[idx].scene;
  await fetch('/api/test_scene', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ scene, fade_ms:0, duration_ms:3000 })});
  status('Test Szene abgespielt');
}

function addButton(){
  const nextIdx = nextFreeIndex();
  STATE.buttons.push({index:nextIdx, label:'New Scene', scene:{type:'static', all:{r:255,g:190,b:120,w:0}}});
  renderButtons();
}
function delButton(btn){
  const idx=parseInt(btn.closest('.card').dataset.idx);
  STATE.buttons.splice(idx,1);
  renderButtons();
}

reloadState();
</script>